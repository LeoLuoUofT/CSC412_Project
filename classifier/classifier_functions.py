import numpy as np
import pandas as pd
from sklearn.neural_network import MLPClassifier
from sklearn.svm import SVC
import pretty_midi
import warnings
import os
import pickle

def get_matched_midi(midi_folder, classes):
    """
    This function loads in midi file paths that are found in the given folder, puts this data into a
    pandas DataFrame, then matches each entry with a genre described in get_genres.
    
    @input midi_folder: The path to the midi files.
    @type midi_folder: String
    @input genre_df: The genre label dataframe generated by get_genres.
    @type genre_df: pandas.DataFrame
    
    @return: A dataframe of track id and path to a midi file with that track id.
    @rtype: pandas.DataFrame
    """
    # Get All Midi Files
    genres = []
    file_paths = []

    for dir_name, subdir_list, file_list in os.walk(midi_folder):
        for name in file_list:
            _path = dir_name.replace("\\","/") + "/"
            _name = name
            if _name.endswith('.mid') or _name.endswith(".midi"):
                shortpath = _path[len(midi_folder):]

                for i, c in enumerate(classes):
                    
                    if c.lower() in shortpath.lower():
                        print("Importing " + c + " song called " + _name)
                        genres.append(c)
                        file_paths.append(os.path.join(dir_name, _name))
                        break

    print("{} songs found".format(len(genres)))
    
    df = pd.DataFrame({"Genre": genres, "Path": file_paths})

    return df

def normalize_features(features):
    """
    This function normalizes the features to the range [-1, 1]
    
    @input features: The array of features.
    @type features: List of float
    
    @return: Normalized features.
    @rtype: List of float
    """
    tempo = (features[0] - 150) / 300
    num_sig_changes = (features[1] - 2) / 10
    resolution = (features[2] - 260) / 400
    time_sig_1 = (features[3] - 3) / 8
    time_sig_2 = (features[4] - 3) / 8
    return [tempo, resolution, time_sig_1, time_sig_2]


def get_features(path):
    """
    This function extracts the features from a midi file when given its path.
    
    @input path: The path to the midi file.
    @type path: String
    
    @return: The extracted features.
    @rtype: List of float
    """
    try:
        # Test for Corrupted Midi Files
        with warnings.catch_warnings():
            warnings.simplefilter("error")
            file = pretty_midi.PrettyMIDI(path)
            
            tempo = file.estimate_tempo()
            num_sig_changes = len(file.time_signature_changes)
            resolution = file.resolution
            ts_changes = file.time_signature_changes
            ts_1 = 4
            ts_2 = 4
            if len(ts_changes) > 0:
                ts_1 = ts_changes[0].numerator
                ts_2 = ts_changes[0].denominator
            return normalize_features([tempo, num_sig_changes, resolution, ts_1, ts_2])
    except:
        return None

def extract_midi_features(path_df,class_to_idx, load_from_pkl = False, pickle_file = None):
    """
    This function takes in the path DataFrame, then for each midi file, it extracts certain
    features, maps the genre to a number and concatenates these to a large design matrix to return.
    
    @input path_df: A dataframe with paths to midi files, as well as their corresponding matched genre.
    @type path_df: pandas.DataFrame
    
    @return: A matrix of features along with label.
    @rtype: numpy.ndarray of float
    """
    if load_from_pkl:
        print("loading from pickle")
        with open(pickle_file, 'rb') as handle:
            r = pickle.load(handle)
        return r
    else:
        print("loading data from scratch")
        all_features = []
        n = len(path_df)
        for index, row in path_df.iterrows():
            if index%100 == 0:
                print("Extracting song {}/{}".format(index, n))
            features = get_features(row.Path)
            genre = class_to_idx[row.Genre] # convert string class to int

            if features is not None:
                features.append(genre)
                all_features.append(features)

        r = np.array(all_features)

        print("Saving processed data to pickle")
        with open(pickle_file, 'wb') as handle:
            pickle.dump(r, handle, protocol=pickle.HIGHEST_PROTOCOL)
        return r

def one_hot(labels,num_classes):
    """
    This function encodes the labels using one-hot encoding.
    
    @input num_classes: The number of genres/classes.
    @type num_classes: int
    @input labels: The genre labels to encode.
    @type labels: numpy.ndarray of int
    
    @return: The one-hot encoding of the labels.
    @rtype: numpy.ndarray of int
    """
    return np.eye(num_classes)[labels].astype(int)

def get_accuracy(clf, x_val, y_val):
    predictions = clf.predict(x_val)
    count = 0
    for i in range(len(y_val)):
        if (type(clf) != SVC):
            if np.array_equal(y_val[i], predictions[i]):
                count += 1
        else:
            if y_val[i] == predictions[i]:
                count += 1
    accuracy = count / len(v_labels_hot)
    return accuracy